<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>最小化测试</title>
  <style>
    body { margin: 20px; background: #f0f0f0; }
    canvas { border: 2px solid #000; display: block; margin: 20px auto; background: white; }
    .log { font-family: monospace; margin: 5px 0; }
    .error { color: red; font-weight: bold; }
    .success { color: green; font-weight: bold; }
  </style>
</head>
<body>
  <h1>五子棋最小化测试</h1>
  <div id="logs"></div>
  <canvas id="game-canvas"></canvas>
  
  <script>
    const log = (msg, isError = false) => {
      const div = document.createElement('div');
      div.className = 'log ' + (isError ? 'error' : 'success');
      div.textContent = msg;
      document.getElementById('logs').appendChild(div);
      console.log(msg);
    };
    
    log('=== 开始测试 ===');
    
    // 1. 测试 canvas 获取
    const canvas = document.getElementById('game-canvas');
    if (!canvas) {
      log('❌ Canvas 元素不存在', true);
    } else {
      log('✅ Canvas 元素获取成功');
      
      // 2. 设置 canvas 尺寸
      const cellSize = 36;
      const padding = 40;
      const boardSize = 15;
      const canvasSize = cellSize * (boardSize - 1) + padding * 2;
      
      log(`计算的Canvas尺寸: ${canvasSize}px (cellSize=${cellSize}, boardSize=${boardSize}, padding=${padding})`);
      
      canvas.width = canvasSize;
      canvas.height = canvasSize;
      canvas.style.width = canvasSize + 'px';
      canvas.style.height = canvasSize + 'px';
      
      log(`✅ Canvas尺寸设置为: ${canvas.width}x${canvas.height}`);
      
      // 3. 测试绘图
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        log('❌ 无法获取2D上下文', true);
      } else {
        log('✅ 2D上下文获取成功');
        
        // 绘制背景
        ctx.fillStyle = '#f4e4bc';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        log('✅ 绘制背景色 #f4e4bc');
        
        // 绘制棋盘线
        ctx.strokeStyle = '#8b7355';
        ctx.lineWidth = 1;
        
        for (let i = 0; i < boardSize; i++) {
          const pos = padding + i * cellSize;
          
          // 横线
          ctx.beginPath();
          ctx.moveTo(padding, pos);
          ctx.lineTo(padding + (boardSize - 1) * cellSize, pos);
          ctx.stroke();
          
          // 竖线
          ctx.beginPath();
          ctx.moveTo(pos, padding);
          ctx.lineTo(pos, padding + (boardSize - 1) * cellSize);
          ctx.stroke();
        }
        log(`✅ 绘制了 ${boardSize}x${boardSize} 条线`);
        
        // 绘制星位点
        const starPositions = [
          { x: 3, y: 3 },
          { x: 11, y: 3 },
          { x: 7, y: 7 },
          { x: 3, y: 11 },
          { x: 11, y: 11 },
        ];
        
        ctx.fillStyle = '#8b7355';
        starPositions.forEach(pos => {
          const screenX = padding + pos.x * cellSize;
          const screenY = padding + pos.y * cellSize;
          ctx.beginPath();
          ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);
          ctx.fill();
        });
        log('✅ 绘制了 5 个星位点');
        
        // 绘制几个测试棋子
        const pieceRadius = 15;
        
        // 黑子
        ctx.fillStyle = '#2f2f2f';
        const blackX = padding + 7 * cellSize;
        const blackY = padding + 7 * cellSize;
        ctx.beginPath();
        ctx.arc(blackX, blackY, pieceRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
        log('✅ 绘制了一个黑子在中心');
        
        // 白子
        ctx.fillStyle = '#f0f0f0';
        const whiteX = padding + 8 * cellSize;
        const whiteY = padding + 7 * cellSize;
        ctx.beginPath();
        ctx.arc(whiteX, whiteY, pieceRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.stroke();
        log('✅ 绘制了一个白子');
        
        log('=== ✅ 测试完成！棋盘应该已经显示 ===');
      }
    }
  </script>
</body>
</html>
